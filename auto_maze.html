<div id="app">
    <div>
        游戏规则：红色为玩家.绿色为目的地.w上移一格.s下移一格.a左移一格.d右移一格
    </div>
    size:<input type="text" id="sizeInput" value="30" />
    <button id="createMapBtn">自动生成地图</button>
    <button id="autoMove">自动寻路</button>
    <span id="degreeOfDifficulty"></span>
    <br />
    <br />
    <canvas id="canvas"></canvas>
    <script src="./index.js"></script>
</div>

<script>
let mapInfo, player, target, tileConfig;
let isGameOver = false;
const tileWidth = 20,
    tileHeight = 20;
//   地形映射
const mapType = {
    WALL_ALL: -1,
    FLOOR_SMOOTH: 1,
    FLOOR_GRID: 2,
    FLOOR_BROKE: 3,
    FLOOR_BROKEN: 4,
    WALL_TOP_BOTTOM: 5,
    WALL_TOP_BOTTOM_1: 6,
    WALL_TOP_BOTTOM_2: 7,
    WALL_TOP_BOTTOM_3: 8,
    WALL_LEFT_RIGHT: 9,
    WALL_LEFT_RIGHT_1: 10,
    WALL_LEFT_RIGHT_2: 11,
    WALL_ROW_RED_EYE: 12,
    WALL_RIGHT_TOP: 13,
    WALL_LEFT_TOP: 14,
    WALL_LEFT_BOTTOM: 15,
    WALL_RIGHT_BOTTOM: 16,
    WALL_ALL_SECONDE_MIDDLE: 17,
    WALL_ALL_SECONDE_LEFT: 18,
    WALL_ALL_SECONDE_RIGHT: 19,
    WALL_RIGHT: 20,
    WALL_LEFT: 21,
    WALL_BOTTOM: 22,
    WALL_TOP: 23,
    WALL_SINGLE: 24,
    WALL_RIGHT_TOP_BOTTOM: 25,
    WALL_LEFT_TOP_BOTTOM: 26,
    WALL_LEFT_RIGHT_BOTTOM: 27,
    WALL_LEFT_RIGHT_TOP: 28,
};

// 地形瓦片图
const tileMapPng =
    "data:image/png;base64,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";
// 马尔可夫算法自动生成迷宫
const markov = (function () {
    function getAllIndexes(arr, val) {
        const indexes = [],
            i = -1;
        while ((i = arr.indexOf(val, i + 1)) != -1) {
            indexes.push(i);
        }
        return indexes;
    }

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getIndexesOfField(field, pattern) {
        let i = 0;
        let indexes = [];
        for (const row of field) {
            const rowIndexes = getAllIndexes(row, pattern);
            indexes = indexes.concat(rowIndexes.map((j) => [i, j, "right"]));
            i++;
        }
        return indexes;
    }

    function isMatchLeft(field, pattern, i, j) {
        for (let k = 0; k < pattern.length; k++) {
            if (j - k < 0) {
                return false;
            }
            if (pattern[k] == "*") {
                continue;
            }
            if (field[i][j - k] != pattern[k]) {
                return false;
            }
        }
        return true;
    }

    function isMatchRight(field, pattern, i, j) {
        for (let k = 0; k < pattern.length; k++) {
            if (j + k >= field[i].length) {
                return false;
            }
            if (pattern[k] == "*") {
                continue;
            }
            if (field[i][j + k] != pattern[k]) {
                return false;
            }
        }
        return true;
    }

    function isMatchUp(field, pattern, i, j) {
        for (let k = 0; k < pattern.length; k++) {
            if (i - k < 0) {
                return false;
            }
            if (pattern[k] == "*") {
                continue;
            }
            if (field[i - k][j] != pattern[k]) {
                return false;
            }
        }
        return true;
    }

    function isMatchDown(field, pattern, i, j) {
        for (let k = 0; k < pattern.length; k++) {
            if (i + k >= field.length - 1) {
                return false;
            }
            if (pattern[k] == "*") {
                continue;
            }
            if (field[i + k][j] != pattern[k]) {
                return false;
            }
        }
        return true;
    }

    function getAllMatches(field, pattern) {
        let indexes = [];
        for (let i = 0; i < field.length; i++) {
            let row = field[i];
            for (let j = 0; j < row.length; j++) {
                if (isMatchUp(field, pattern, i, j)) {
                    indexes.push([i, j, "up"]);
                }
                if (isMatchDown(field, pattern, i, j)) {
                    indexes.push([i, j, "down"]);
                }
                if (isMatchLeft(field, pattern, i, j)) {
                    indexes.push([i, j, "left"]);
                }
                if (isMatchRight(field, pattern, i, j)) {
                    indexes.push([i, j, "right"]);
                }
            }
        }
        return indexes;
    }

    function applyMatch(field, match, pattern) {
        const i = match[0];
        const j = match[1];
        const dir = match[2];

        if (dir == "up") {
            for (let k = 0; k < pattern.length; k++) {
                if (pattern[k] == "*") {
                    continue;
                }
                field[i - k][j] = pattern[k];
            }
        }
        if (dir == "down") {
            for (let k = 0; k < pattern.length; k++) {
                if (pattern[k] == "*") {
                    continue;
                }
                field[i + k][j] = pattern[k];
            }
        }
        if (dir == "left") {
            for (let k = 0; k < pattern.length; k++) {
                if (pattern[k] == "*") {
                    continue;
                }
                field[i][j - k] = pattern[k];
            }
        }
        if (dir == "right") {
            for (let k = 0; k < pattern.length; k++) {
                if (pattern[k] == "*") {
                    continue;
                }
                field[i][j + k] = pattern[k];
            }
        }
    }

    function* all(field, prog) {
        let anyMatches = false;
        while (true) {
            for (const result of markov(field, prog)) {
                if (!result) {
                    return;
                }
                yield true;
            }
        }
    }

    function* one(field, pattern) {
        const target = pattern[0];
        const replace = pattern[1];
        const matches = getAllMatches(field, target);
        if (matches.length == 0) {
            yield false;
            return;
        }
        const chosen = getRandomInt(0, matches.length - 1);
        const match = matches[chosen];
        applyMatch(field, match, replace);
        yield true;
    }

    function* sequence(field, prog) {
        let anyMatch = false;
        for (const pattern of prog) {
            for (const result of markov(field, pattern)) {
                if (result) {
                    anyMatch = true;
                }
                yield true;
            }
        }
        if (!anyMatch) {
            console.log("sequence DONE");
            yield false;
        }
    }

    return function* markov(field, prog) {
        if (prog.length == 0) {
            yield false;
            return;
        }
        switch (true) {
            case typeof prog[0] == "object":
                yield* sequence(field, prog);
                break;
            case prog[0] == "all":
                yield* all(field, prog[1]);
                break;
            default:
                yield* one(field, prog);
        }
    };
})();

// 对生成的迷宫地图进行转换.转换成更合理的地形
const adjustMap = (function () {
    function getMapType(mapList, x, y) {
        const [
            left,
            leftTop,
            top,
            rightTop,
            right,
            rightBottom,
            bottom,
            leftBottoom,
        ] = [
                (mapList[y] || [])[x - 1] || "W",
                (mapList[y - 1] || [])[x - 1] || "W",
                (mapList[y - 1] || [])[x] || "W",
                (mapList[y - 1] || [])[x + 1] || "W",
                (mapList[y] || [])[x + 1] || "W",
                (mapList[y + 1] || [])[x + 1] || "W",
                (mapList[y + 1] || [])[x] || "W",
                (mapList[y + 1] || [])[x - 1] || "W",
            ];
        if (
            left !== "W" &&
            right !== "W" &&
            bottom !== "W" &&
            (leftBottoom === "W" || rightBottom === "W") &&
            (top === "W" || (top !== "W" && leftTop !== "W" && rightTop !== "W"))
        ) {
            return mapType.WALL_LEFT_RIGHT_BOTTOM;
        }
        if (
            left !== "W" &&
            right !== "W" &&
            top !== "W" &&
            bottom === "W" &&
            leftTop === "W" &&
            rightTop === "W" &&
            leftBottoom === "W" &&
            rightBottom === "W"
        ) {
            return mapType.WALL_LEFT_RIGHT_TOP;
        }
        if (
            left !== "W" &&
            bottom !== "W" &&
            top !== "W" &&
            leftTop === "W" &&
            leftBottoom === "W" &&
            (rightTop === "W" ||
                (rightTop !== "W" && right !== "W" && rightBottom !== "W"))
        ) {
            return mapType.WALL_LEFT_TOP_BOTTOM;
        }
        if (
            right !== "W" &&
            bottom !== "W" &&
            top !== "W" &&
            rightTop === "W" &&
            rightBottom === "W" &&
            (left === "W" || (left !== "W" && leftTop !== "W" && leftBottoom !== "W"))
        ) {
            return mapType.WALL_RIGHT_TOP_BOTTOM;
        }
        if (
            right !== "W" &&
            bottom !== "W" &&
            top !== "W" &&
            left !== "W" &&
            (leftTop === "W" ||
                rightTop === "W" ||
                leftBottoom === "W" ||
                rightBottom === "W")
        ) {
            if (
                leftTop !== "W" &&
                rightTop !== "W" &&
                leftBottoom === "W" &&
                rightBottom !== "W"
            ) {
                return mapType.WALL_LEFT_BOTTOM;
            }
            if (
                leftTop !== "W" &&
                rightTop !== "W" &&
                leftBottoom !== "W" &&
                rightBottom === "W"
            ) {
                return mapType.WALL_RIGHT_BOTTOM;
            }
            if (
                leftTop === "W" &&
                rightTop !== "W" &&
                leftBottoom !== "W" &&
                rightBottom !== "W"
            ) {
                return mapType.WALL_LEFT_TOP;
            }
            if (
                leftTop !== "W" &&
                rightTop === "W" &&
                leftBottoom !== "W" &&
                rightBottom !== "W"
            ) {
                return mapType.WALL_RIGHT_TOP;
            }
            if (
                leftTop === "W" &&
                rightTop === "W" &&
                leftBottoom !== "W" &&
                rightBottom !== "W"
            ) {
                return mapType.WALL_LEFT_RIGHT_1;
            }
            return mapType.WALL_LEFT_RIGHT_BOTTOM;
        }
        if (
            right !== "W" &&
            bottom !== "W" &&
            top !== "W" &&
            left !== "W" &&
            leftTop !== "W" &&
            rightTop !== "W" &&
            leftBottoom !== "W" &&
            rightBottom !== "W"
        ) {
            return mapType.WALL_ALL;
        }
        if (
            right === "W" &&
            bottom === "W" &&
            top === "W" &&
            left !== "W" &&
            leftTop === "W" &&
            rightTop === "W" &&
            leftBottoom === "W" &&
            rightBottom === "W"
        ) {
            return mapType.WALL_LEFT;
        }
        if (
            right !== "W" &&
            bottom === "W" &&
            top === "W" &&
            left === "W" &&
            leftTop === "W" &&
            rightTop === "W" &&
            leftBottoom === "W" &&
            rightBottom === "W"
        ) {
            return mapType.WALL_RIGHT;
        }
        if (
            right === "W" &&
            bottom === "W" &&
            top !== "W" &&
            left === "W" &&
            leftTop === "W" &&
            rightTop === "W" &&
            leftBottoom === "W" &&
            rightBottom === "W"
        ) {
            return mapType.WALL_TOP;
        }
        if (
            right === "W" &&
            bottom !== "W" &&
            top === "W" &&
            left === "W" &&
            leftTop === "W" &&
            rightTop === "W" &&
            leftBottoom === "W" &&
            rightBottom === "W"
        ) {
            return mapType.WALL_BOTTOM;
        }
        if (right === "W" && bottom === "W" && left !== "W" && top !== "W") {
            return mapType.WALL_LEFT_TOP;
        }
        if (right === "W" && top === "W" && left !== "W" && bottom !== "W") {
            return mapType.WALL_LEFT_BOTTOM;
        }
        if (left === "W" && bottom === "W" && right !== "W" && top !== "W") {
            return mapType.WALL_RIGHT_TOP;
        }
        if (left === "W" && top === "W" && right !== "W" && bottom !== "W") {
            return mapType.WALL_RIGHT_BOTTOM;
        }
        if ((top === "W" || bottom === "W") && left !== "W" && right !== "W") {
            return mapType.WALL_LEFT_RIGHT;
        }
        if ((left === "W" || right === "W") && top !== "W" && bottom !== "W") {
            return mapType.WALL_TOP_BOTTOM;
        }
    }

    function checkWallAllSecond(type, mapList, x, y) {
        if (type !== mapType.WALL_ALL) return type;
        const [top] = [(mapList[y - 1] || [])[x] || "W"];
        if (
            top !== "W" &&
            top !== mapType.WALL_ALL &&
            top !== mapType.WALL_ALL_SECONDE_MIDDLE
        ) {
            return mapType.WALL_ALL_SECONDE_MIDDLE;
        }
        return type;
    }

    function checkWallAllSecondType(type, mapList, x, y) {
        if (type === "W") return mapType.FLOOR_SMOOTH;
        if (type !== mapType.WALL_ALL_SECONDE_MIDDLE) return type || "G";
        const [left, right] = [
            (mapList[y] || [])[x - 1] || mapType.FLOOR_SMOOTH,
            (mapList[y] || [])[x + 1] || mapType.FLOOR_SMOOTH,
        ];
        if (
            ![
                mapType.WALL_ALL_SECONDE_LEFT,
                mapType.WALL_ALL_SECONDE_MIDDLE,
                mapType.WALL_ALL_SECONDE_RIGHT,
            ].includes(left)
        ) {
            return mapType.WALL_ALL_SECONDE_LEFT;
        }
        if (
            ![
                mapType.WALL_ALL_SECONDE_LEFT,
                mapType.WALL_ALL_SECONDE_MIDDLE,
                mapType.WALL_ALL_SECONDE_RIGHT,
            ].includes(right)
        ) {
            return mapType.WALL_ALL_SECONDE_RIGHT;
        }
        return type;
    }

    return function adjustMap(mapList) {
        const result = [];
        mapList.forEach((row, y) => {
            result[y] = [];
            row.forEach((col, x) => {
                if (col !== "W") {
                    const type = getMapType(mapList, x, y);
                    result[y].push(checkWallAllSecond(type, result, x, y));
                } else {
                    result[y].push(col);
                }
            });
        });
        result.forEach((row, y) => {
            row.forEach((type, x) => {
                result[y][x] = checkWallAllSecondType(type, result, x, y);
            });
        });
        return result;
    };
})();

// 随机获取一个可以作为特殊用途的可通行的地块
const getTargetTile = (function () {
    function getRandInt(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }
    return function getTargetTile(map, excludes) {
        let x, y, tile;
        const ext = excludes || [];
        do {
            x = getRandInt(0, map[0].length);
            y = getRandInt(0, map.length);
            tile = map[y][x];
        } while (
            tile !== 1 ||
            ext.some(({ x: ex, y: ey }) => ex === x && ey === y)
        );
        return { x, y };
    };
})();
// 自动寻路算法
function aStartFindPath(start, end, tileInfo) {
    const [tx, ty] = end.split("_").map(Number);
    const targetTile = { x: tx, y: ty };
    const closeTileMap = {};
    const openTileMap = {};
    function findPathToTarget(current, prePath, preG) {
        const { x, y } = current;
        const currentPath = prePath ? `${prePath}@${x}_${y}` : `${x}_${y}`;
        closeTileMap[`${x}_${y}`] = current;
        const openMap = {};
        const [left, top, right, bottom] = [
            (tileInfo[y] || [])[x - 1],
            (tileInfo[y - 1] || [])[x],
            (tileInfo[y] || [])[x + 1],
            (tileInfo[y + 1] || [])[x],
        ];
        const neighbors = [left, top, right, bottom].filter(Boolean);
        const tTile = checkIsTarget(targetTile, neighbors);
        if (tTile) {
            closeTileMap[`${tTile.x}_${tTile.y}`] = tTile;
            return currentPath + `@${tTile.x}_${tTile.y}`;
        }
        let minFTile;
        // 找出F最小的那个地图
        neighbors.forEach((tileTile) => {
            if (!isClosed(tileTile)) {
                const tileData = getValue(targetTile, tileTile, preG, currentPath);
                minFTile = getMinFTile(minFTile, tileData);
                openMap[tileData.key] = tileData;
            }
        });
        if (!minFTile) {
            if (!Object.keys(openTileMap).length) return null;
            // 如果周边没有这种地图块.从其他openTile中找
            Object.keys(openTileMap).forEach((key) => {
                const curTile = openTileMap[key];
                if (!minFTile) minFTile = curTile;
                else if (minFTile.F > curTile.F) {
                    minFTile = curTile;
                }
            });
        } else {
            Object.keys(openMap).forEach((key) => {
                if (!(openTileMap[key] && openTileMap[key].G < openMap[key].G)) {
                    openTileMap[key] = openMap[key];
                }
            });
        }
        const mFkey = minFTile.key;
        minFTile = openTileMap[mFkey];
        delete openTileMap[mFkey];
        return findPathToTarget(
            tileInfo[minFTile.y][minFTile.x],
            minFTile.prePath,
            minFTile.G
        );
    }

    function checkIsTarget(target, tileList) {
        return tileList.find((tile) => tile.x === target.x && tile.y === target.y);
    }

    function getMinFTile(minFTile, currentTile) {
        if (!minFTile) return currentTile;
        if (minFTile.F > currentTile.F) return currentTile;
        return minFTile;
    }

    function getValue(target, tile, preG, prePath) {
        const G = preG + 1,
            H = Math.abs(target.x - tile.x) + Math.abs(target.y - tile.y),
            F = G + H;
        return {
            x: tile.x,
            y: tile.y,
            prePath,
            key: `${tile.x}_${tile.y}`,
            G,
            H,
            F,
        };
    }

    function isClosed(tile) {
        return !tile || closeTileMap[`${tile.x}_${tile.y}`] || !tile.moveable;
    }

    const [x, y] = start.split("_").map(Number);
    const path = findPathToTarget(tileInfo[y][x], "", 0);
    return path ? path.split("@").map((key) => closeTileMap[key]) : null;
}

const createMap = (function () {
    let field = [];
    let machine = null;
    let startTime = 0;
    let size = 30;
    let baCount = 3;
    let floorCount = 0;
    let floorRatio = 0;
    let singleCountRatio = 0;
    let rightPathRatio = 0;
    const xml = `
<plist version="1.0">
<dict>
<key>frames</key>
<dict>
    <key>tile (1).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{0,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (10).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{960,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (11).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1280,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (12).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1600,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (13).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{0,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (14).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{320,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (15).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{640,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (16).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{960,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (17).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1280,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (18).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1600,640},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (19).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{0,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (2).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{320,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (20).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{320,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (21).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{640,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (22).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{960,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (23).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1280,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (24).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1600,960},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (25).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{0,1280},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (26).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{320,1280},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (27).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{640,1280},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (28).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{960,1280},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (3).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{640,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (4).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{960,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (5).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1280,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (6).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{1600,0},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (7).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{0,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (8).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{320,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
    <key>tile (9).png</key>
    <dict>
        <key>aliases</key>
        <array/>
        <key>spriteOffset</key>
        <string>{0,0}</string>
        <key>spriteSize</key>
        <string>{320,320}</string>
        <key>spriteSourceSize</key>
        <string>{320,320}</string>
        <key>textureRect</key>
        <string>{{640,320},{320,320}}</string>
        <key>textureRotated</key>
        <false/>
    </dict>
</dict>
<key>metadata</key>
<dict>
    <key>format</key>
    <integer>3</integer>
    <key>pixelFormat</key>
    <string>RGBA8888</string>
    <key>premultiplyAlpha</key>
    <false/>
    <key>realTextureFileName</key>
    <string>tile.png</string>
    <key>size</key>
    <string>{1920,1600}</string>
    <key>smartupdate</key>
    <string>$TexturePacker:SmartUpdate:e4f8d7df5eab2b4053f289dd952a4fa3:1f87f39e9554c700cc6ed562499e4da1:a3dc05273f13e152d9d672105aa4a137$</string>
    <key>textureFileName</key>
    <string>tile.png</string>
</dict>
</dict>
</plist>
`;

    tileConfig = getXMLNode(xml);
    function getXMLNode(xml) {
        //创建文档对象

        const xmlDoc = new DOMParser().parseFromString(xml, "text/xml");
        const pList = xmlDoc.querySelector("plist dict > dict");

        const dictList = pList.childNodes;
        const tilesMap = {};
        let dictKey = "";
        dictList.forEach((child) => {
            if (child.nodeType === 3) return;
            if (child.nodeName === "key") {
                const key = child.textContent.match(/(\d+)/)[1];
                dictKey = key;
            } else {
                const dictMap = {};
                let nodeKey;
                child.childNodes.forEach((node) => {
                    if (node.nodeType === 3) return;
                    if (node.nodeName === "key") {
                        nodeKey = node.textContent;
                    } else if (node.nodeName === "array") {
                        dictMap[nodeKey] = [];
                    } else if (node.nodeName === "string") {
                        dictMap[nodeKey] = JSON.parse(
                            node.textContent.replaceAll("{", "[").replaceAll("}", "]")
                        );
                    } else if (node.nodeName === "false") {
                        dictMap[nodeKey] = false;
                    } else if (node.nodeName === "true") {
                        dictMap[nodeKey] = true;
                    }
                });
                tilesMap[dictKey] = dictMap;
            }
        });
        return tilesMap;
    }

    function draw(mapInfo) {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = size * tileWidth;
        canvas.height = size * tileHeight;
        const img = document.createElement("img");

        img.onload = function () {
            mapInfo.forEach((row, y) => {
                row.forEach((type, x) => {
                    const config = tileConfig[type];
                    const [ox, oy] = [x * tileWidth, y * tileHeight];
                    if (config) {
                        const { textureRect } = config;
                        const [[sx, sy], [sw, sh]] = textureRect;
                        ctx.drawImage(this, sx, sy, sw, sh, ox, oy, tileWidth, tileHeight);
                    } else {
                        ctx.fillStyle = "black";
                        ctx.fillRect(ox, oy, tileWidth, tileHeight);
                    }
                });
            });
            drawTarget(player, "#f00");
            drawTarget(target, "#0f0");
        };
        img.src = tileMapPng;
    }

    function drawLoading(tips) {
        if (startTime === 0) startTime = Date.now();
        const during = Math.floor((Date.now() - startTime) / 1000);
        const canvas = document.getElementById("canvas");
        canvas.width = size * tileWidth;
        canvas.height = size * tileHeight;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, size * tileWidth, size * tileHeight);
        ctx.fillStyle = "#fff";
        ctx.fillText(
            tips
                ? tips
                : `地图加载中.已运行${during}s.请稍后${new Array((during % 6) + 1)
                    .fill(".")
                    .join(" ")}`,
            (size / 2 - 4) * tileWidth,
            2 * tileHeight
        );
    }

    function drawRightPaht(pathList) {
        if (pathList.length > 0) {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "blue";
            pathList.forEach((tile) => {
                ctx.beginPath();
                ctx.arc(
                    (tile.x + 0.5) * tileWidth,
                    (tile.y + 0.5) * tileHeight,
                    tileWidth / 4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.closePath();
            });
        }
    }

    function update() {
        if (machine) {
            const running = machine.next();
            if (running.done) {
                if (checkMapInfo(field)) {
                    machine = null;
                    console.log("DONE");
                    mapInfo = adjustMap(field);
                    player = getTargetTile(mapInfo, []);
                    target = getTargetTile(mapInfo, [player]);
                    const pathList = findRightPath(player, target, mapInfo);
                    if (pathList) {
                        getSingleBlockRatio(mapInfo);
                        calcDegreeOfDifficulty();
                        draw(mapInfo);
                        startTime = 0;
                    } else {
                        runMarkov();
                    }
                } else {
                    runMarkov();
                }
            } else {
                drawLoading();
            }
        }
    }

    function runMarkov() {
        target = null;
        player = null;
        floorCount = 0;
        floorRatio = 0;
        singleCountRatio = 0;
        rightPathRatio = 0;
        const baList = new Array(baCount).fill(["B", "A"]);
        field = new Array(size).fill(1).map((_, i) =>
            new Array(size).fill("B").map((_, j) => {
                if (i === 0 || i === size - 1) return "G";
                else if (j === 0 || j === size - 1) return "G";
                return "B";
            })
        );
        const prog = [
            ...baList,
            ["all", ["BA", "AP"]],
            ["all", ["A", "G"]],
            ["all", ["P", "G"]],
            ["B", "R"],
            [
                "all",
                [
                    ["all", ["RBB", "UUR"]],
                    ["RUU", "WWR"],
                ],
            ],
            ["all", ["G", "B"]],
            ["all", ["R", "W"]],
        ];
        machine = markov(field, prog);
    }

    window.onload = function () {
        drawLoading("请点击按钮生成地图");
        setInterval(update, 1); // 33 milliseconds = ~ 30 frames per sec
    };

    function checkMapInfo(field) {
        floorCount = 0;
        field.forEach((row) => {
            row.forEach((cell) => {
                if (cell === "W") {
                    floorCount += 1;
                }
            });
        });
        const total = size * size;
        floorRatio = floorCount / total;
        if (floorRatio < 0.3) return false;
        return true;
    }

    function findRightPath(player, target, mapInfo) {
        const pathList = findPath(player, target, mapInfo);
        const pCount = pathList.length;
        rightPathRatio = pCount / floorCount;
        if (rightPathRatio < 0.1) return null;
        return pathList;
    }

    function getSingleBlockRatio(mapInfo) {
        let singleCount = 0;
        mapInfo.forEach((row) => {
            row.forEach((type) => {
                if (
                    [
                        mapType.WALL_RIGHT,
                        mapType.WALL_LEFT,
                        mapType.WALL_TOP,
                        mapType.WALL_BOTTOM,
                    ].includes(type)
                ) {
                    singleCount++;
                }
            });
        });
        singleCountRatio = singleCount / floorCount;
    }

    function calcDegreeOfDifficulty() {
        const ratio =
            (size / 10) *
            (floorRatio * 1 + singleCountRatio * 2 + rightPathRatio * 3);
        document.getElementById(
            "degreeOfDifficulty"
        ).innerText = `难度系数${ratio.toFixed(2)}`;
        return ratio;
    }

    return function createMap() {
        isGameOver = false;
        mapInfo = null;
        document.getElementById("degreeOfDifficulty").innerText = "";
        startTime = 0;
        const sizeInput = document.getElementById("sizeInput");
        size = Number(sizeInput.value || 30);
        baCount = Math.floor(size / 10) + 1;
        runMarkov();
    };
})();

// 自动行走
let timer;
let autoMoveIndex = 0;
let isAutoMovePause = false;
function autoMove() {
    isAutoMovePause = false;
    if (!(mapInfo && player && target)) return;
    if (timer) clearTimeout(timer);
    autoMoveIndex = 0;
    const pathList = findPath(player, target, mapInfo);
    function move() {
        if (autoMoveIndex < pathList.length && !isAutoMovePause) {
            if (timer) clearTimeout(timer);
            const next = pathList[autoMoveIndex];
            drawTile(player);
            player = next;
            drawTarget(next, "#f00");
            autoMoveIndex += 1;
            timer = setTimeout(move, 300);
        }
        if (autoMoveIndex === pathList.length) {
            isGameOver = true;
        }
    }
    move();
}

function findPath(player, target, mapInfo) {
    const tileInfo = mapInfo.map((row, y) => {
        return row.map((type, x) => ({
            x,
            y,
            type,
            moveable: type === 1,
        }));
    });
    const start = `${player.x}_${player.y}`;
    const end = `${target.x}_${target.y}`;
    const pathList = aStartFindPath(start, end, tileInfo);
    return pathList;
}

function drawTarget(point, color) {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = color;
    ctx.fillRect(
        point.x * tileWidth,
        point.y * tileHeight,
        tileWidth,
        tileHeight
    );
}

function drawTile(point) {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const img = document.createElement("img");
    img.onload = function () {
        const { x, y } = point;
        const config = tileConfig[mapType.FLOOR_SMOOTH];
        const [ox, oy] = [x * tileWidth, y * tileHeight];
        const { textureRect } = config;
        const [[sx, sy], [sw, sh]] = textureRect;
        ctx.drawImage(this, sx, sy, sw, sh, ox, oy, tileWidth, tileHeight);
    };
    img.src = tileMapPng;
}

document.getElementById("createMapBtn").addEventListener("click", createMap);
document.getElementById("autoMove").addEventListener("click", autoMove);
window.addEventListener("keypress", move);
function move(e) {
    isAutoMovePause = true;
    if (!mapInfo || !player || !target || isGameOver) return;
    const { x: px, y: py } = player;
    const next = { x: px, y: py };
    switch (e.charCode) {
        case 119: // w
            next.y -= 1;
            break;
        case 115: // s
            next.y += 1;
            break;
        case 97: // a
            next.x -= 1;
            break;
        case 100: // d
            next.x += 1;
            break;
        default:
            break;
    }
    const nextTile = mapInfo[next.y][next.x];
    if (nextTile === mapType.FLOOR_SMOOTH) {
        drawTile(player);
        player = next;
        drawTarget(next, "#f00");
    }
    if (player.x === target.x && player.y === target.y) {
        setTimeout(() => {
            isGameOver = true;
            alert("恭喜通关游戏");
        }, 10);
    }
}

</script>